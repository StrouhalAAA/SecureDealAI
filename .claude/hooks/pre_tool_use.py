#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.8"
# ///

"""
Pre-tool-use hook for SecureDealAI.

This hook intercepts every tool call BEFORE execution and:
1. Blocks dangerous rm -rf commands
2. Blocks access to .env files (except .env.sample/.env.example)
3. Logs all tool invocations for audit trail

Exit codes:
- 0: Allow tool to proceed
- 2: Block tool execution (error message shown to Claude)
"""

import json
import sys
import re
import os
from pathlib import Path

from utils.constants import ensure_session_log_dir


def is_dangerous_rm_command(command: str) -> bool:
    """
    Comprehensive detection of dangerous rm commands.
    Matches various forms of rm -rf and similar destructive patterns.
    """
    # Normalize command by removing extra spaces and converting to lowercase
    normalized = ' '.join(command.lower().split())

    # Pattern 1: Standard rm -rf variations
    patterns = [
        r'\brm\s+.*-[a-z]*r[a-z]*f',  # rm -rf, rm -fr, rm -Rf, etc.
        r'\brm\s+.*-[a-z]*f[a-z]*r',  # rm -fr variations
        r'\brm\s+--recursive\s+--force',  # rm --recursive --force
        r'\brm\s+--force\s+--recursive',  # rm --force --recursive
        r'\brm\s+-r\s+.*-f',  # rm -r ... -f
        r'\brm\s+-f\s+.*-r',  # rm -f ... -r
    ]

    # Check for dangerous patterns
    for pattern in patterns:
        if re.search(pattern, normalized):
            return True

    # Pattern 2: Check for rm with recursive flag targeting dangerous paths
    dangerous_paths = [
        r'/',           # Root directory
        r'/\*',         # Root with wildcard
        r'~',           # Home directory
        r'~/',          # Home directory path
        r'\$HOME',      # Home environment variable
        r'\.\.',        # Parent directory references
        r'\*',          # Wildcards in general rm -rf context
        r'\.',          # Current directory
        r'\.\s*$',      # Current directory at end of command
    ]

    if re.search(r'\brm\s+.*-[a-z]*r', normalized):  # If rm has recursive flag
        for path in dangerous_paths:
            if re.search(path, normalized):
                return True

    return False


def is_env_file_access(tool_name: str, tool_input: dict) -> bool:
    """
    Check if any tool is trying to access .env files containing sensitive data.
    Allows access to .env.sample and .env.example templates.
    """
    allowed_env_patterns = ['.env.sample', '.env.example', '.env.local.example']

    if tool_name in ['Read', 'Edit', 'MultiEdit', 'Write', 'Bash']:
        # Check file paths for file-based tools
        if tool_name in ['Read', 'Edit', 'MultiEdit', 'Write']:
            file_path = tool_input.get('file_path', '')
            if '.env' in file_path:
                # Allow template files
                for allowed in allowed_env_patterns:
                    if file_path.endswith(allowed):
                        return False
                return True

        # Check bash commands for .env file access
        elif tool_name == 'Bash':
            command = tool_input.get('command', '')
            # Pattern to detect .env file access (but allow templates)
            env_patterns = [
                r'\b\.env\b(?!\.(sample|example|local\.example))',  # .env but not templates
                r'cat\s+.*\.env\b(?!\.(sample|example))',  # cat .env
                r'echo\s+.*>\s*\.env\b(?!\.(sample|example))',  # echo > .env
                r'touch\s+.*\.env\b(?!\.(sample|example))',  # touch .env
                r'cp\s+.*\.env\b(?!\.(sample|example))',  # cp .env
                r'mv\s+.*\.env\b(?!\.(sample|example))',  # mv .env
            ]

            for pattern in env_patterns:
                if re.search(pattern, command):
                    return True

    return False


def is_supabase_secret_exposure(tool_name: str, tool_input: dict) -> bool:
    """
    Check if Supabase secrets are being exposed in unsafe ways.
    Specifically blocks echoing service role keys to stdout.
    """
    if tool_name == 'Bash':
        command = tool_input.get('command', '')
        # Block echoing Supabase secrets
        dangerous_patterns = [
            r'echo\s+.*SUPABASE_SECRET_KEY',
            r'echo\s+.*SUPABASE_SERVICE_ROLE',
            r'echo\s+.*service_role',
            r'printenv\s+SUPABASE',
        ]
        for pattern in dangerous_patterns:
            if re.search(pattern, command, re.IGNORECASE):
                return True
    return False


def main():
    try:
        # Read JSON input from stdin
        input_data = json.load(sys.stdin)

        tool_name = input_data.get('tool_name', '')
        tool_input = input_data.get('tool_input', {})

        # Check for .env file access (blocks access to sensitive environment files)
        if is_env_file_access(tool_name, tool_input):
            print("BLOCKED: Access to .env files containing sensitive data is prohibited", file=sys.stderr)
            print("Use .env.sample or .env.example for template files instead", file=sys.stderr)
            sys.exit(2)  # Exit code 2 blocks tool call and shows error to Claude

        # Check for Supabase secret exposure
        if is_supabase_secret_exposure(tool_name, tool_input):
            print("BLOCKED: Exposing Supabase secrets to stdout is prohibited", file=sys.stderr)
            sys.exit(2)

        # Check for dangerous rm -rf commands
        if tool_name == 'Bash':
            command = tool_input.get('command', '')

            # Block rm -rf commands with comprehensive pattern matching
            if is_dangerous_rm_command(command):
                print("BLOCKED: Dangerous rm command detected and prevented", file=sys.stderr)
                sys.exit(2)  # Exit code 2 blocks tool call and shows error to Claude

        # Extract session_id
        session_id = input_data.get('session_id', 'unknown')

        # Ensure session log directory exists
        log_dir = ensure_session_log_dir(session_id)
        log_path = log_dir / 'pre_tool_use.json'

        # Read existing log data or initialize empty list
        if log_path.exists():
            with open(log_path, 'r') as f:
                try:
                    log_data = json.load(f)
                except (json.JSONDecodeError, ValueError):
                    log_data = []
        else:
            log_data = []

        # Append new data
        log_data.append(input_data)

        # Write back to file with formatting
        with open(log_path, 'w') as f:
            json.dump(log_data, f, indent=2)

        sys.exit(0)

    except json.JSONDecodeError:
        # Gracefully handle JSON decode errors
        sys.exit(0)
    except Exception:
        # Handle any other errors gracefully
        sys.exit(0)


if __name__ == '__main__':
    main()
